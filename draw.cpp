/*
	Projekt: Depth-First-Search Labyrint
	Namn: Milton Wiklund
	Datum: 2022-08-21
	Betyg siktat mot: C
*/

#include "draw.h"

// Draws out a maze generated by the Depth-First-Search algorithm.
void maze::draw_maze() {
    std::cout << "\n";

    for (int y = 0; y < height; y++) {
        std::cout << " ";
        for (int x = 0; x < width; x++)
            std::cout << node_matrix[x][y].value;
        
        std::cout << "\n";
    }
}

// Draws out the stored DFS path from start to finish.
void maze::draw_DFS_path(std::stack<node>& path) {
    node first_node, second_node, middle_node;
    std::vector<node> path_vector;
    int path_length = 0;

    // Gives the starting and ending nodes a unique color.
    set_node_value(&start_node, RED("██"));
    set_node_value(&end_node, RED("██"));

    // Exception for empty path, appears in a 3x3 maze.
    if (path.empty()) {
        set_node_value(&last_path_node, BLUE("██"));
        draw_maze();
        path_length++;
    }
    else {
        // Copies stack's content to vector.
        while (!path.empty()) {
            path_vector.push_back(path.top());
            path.pop();
        }

        // Reverses vector to sort in ascending order.
        std::reverse(path_vector.begin(), path_vector.end());

        for (int i = 0; i < path_vector.size(); i++) {
            // Collects position of first node from vector.
            first_node = path_vector[i];

            // Checks if not at the end of vector.
            if (i != path_vector.size() - 1) {
                // Collects position of adjacent node from vector (next to first node).
                second_node = path_vector[i + 1];

                // Checks if first and second node is at the same x- or y-level.
                // If true, set middle node to lie between them.
                if (first_node.x == second_node.x) {
                    middle_node.x = first_node.x;
                    middle_node.y = (first_node.y + second_node.y) / 2;
                }
                else if (first_node.y == second_node.y) {
                    middle_node.x = (first_node.x + second_node.x) / 2;
                    middle_node.y = first_node.y;
                }

				// Increases the path length for every middle-node.
				path_length++;
            }
            // If at the end of vector, set second and middle node to be identical to first node.
            // This is to not cause excessive nodes being identified as the path trail, since
            // there is only one node to select if you're at the end of the vector.
            else {
                second_node = first_node;
                middle_node = first_node;
            }

            // Gives the path a unique color.
            set_node_value(&first_node, BLUE("██"));
            set_node_value(&second_node, BLUE("██"));
            set_node_value(&middle_node, BLUE("██"));

            // Animated drawing if drawing speed is not set to 0.
            if (drawing_speed > 0) {
                system("clear");
                draw_maze();
                usleep(drawing_speed);
            }

            // Increases the path length for every normal node.
            path_length++;
        }
    }

    // If drawing speed is set to zero, or matrix is 3x3, an animated drawing will not be presented.
    if (drawing_speed == 0 || size() == 9) {
        system("clear");
        draw_maze();
    }

    // The start- and end-node are not included in the increment of the path-length,
	// therefore an additional two points need to be added afterwards.
    path_length += 2;

    std::cout << "\n Path length: " << path_length << " characters.\n";
    print_maze_resolution();
}